<?php

	/**
	 * class for Views
	 *
	 * @version 0.1.0
	 * @author Alexys Hegmann "Yagarasu" http://alexyshegmann.com
	 */
	class View extends EventTrigger
	{
		// Template
		protected $template = "";

		// Model holder
		protected $models = array();

		// View stack. Prevents infinite loop in remote views: A calls view B, B calls view A.
		protected $stack = array();

		/**
		 * Constructor
		 * @param array $models Assoc array holding the models needed in the view
		 * @param array $stack The array stack if it's an embeded view.
		 */
		public function __construct($models=array(), $stack=array())
		{
			$this->models = $models;
			$this->stack = $stack;
		}

		/**
		 * Registers a model to be used whithin the view
		 * @param  string $modelName     Key used in the template
		 * @param  Object $modelInstance Model to register
		 */
		public function registerModel($modelName, $modelInstance)
		{
			$this->models[$modelName] = $modelInstance;
		}

		/**
		 * Returns the registered model with the $modelName key
		 * @param  string $modelName Key used in the template
		 * @return mixed            The registered model or null if not exists
		 */
		public function getModel($modelName)
		{
			return ($this->modelIsRegistered($modelName)) ? $this->models[$modelName] : null;
		}

		/**
		 * Unregisters a model
		 * @param  string $modelName Key used in the template
		 * @return boolean            True on success, false on error
		 */
		public function unregisterModel($modelName)
		{
			if($this->modelIsRegistered($modelName)) {
				unset($this->models[$modelName]);
				return true;
			}
			return false;
		}

		/**
		 * Checks if a model is registered or not
		 * @param  string $modelName Key used in template
		 * @return boolean            Whether the model is registered or not
		 */
		public function modelIsRegistered($modelName)
		{
			return(array_key_exists($modelName, $this->models));
		}

		/**
		 * Loads from a url a template file
		 * @param  string $templateUrl Route to template
		 * @return boolean              True on success, false on error
		 */
		public function loadTemplate($templateUrl)
		{
			if(preg_match('/^[a-zA-Z]+\:\/\//i', $templateUrl)===1) throw new Exception("You can't import a template with an absolute route.");
			global $cfg;
			$reqPath = $cfg['dirs']['app'].$templateUrl;
			if(is_readable($reqPath)) {
				$this->template = @file_get_contents($reqPath);
				if($this->template===false) {
					$this->template = "";
					$this->triggerEvent("TEMPLATELOAD_ERROR", array(
						"templateUrl"	=> $templateUrl
					));
					return false;
				}
				$this->triggerEvent("TEMPLATELOADED", array(
					"templateUrl"	=> $templateUrl
				));
				return true;
			}
		}

		/**
		 * Returns the text generated by parsing the special tags
		 * @param string $template A string containing or not special tags. If null given, current loaded template is used.
		 * @return string Final text
		 */
		public function parse($template=null)
		{
			$template = ($template===null) ? $this->template : $template;
			$pattern = ''
				.'~\{\s*'									// ~{
				.'(?P<cmd>\$?\w+)(?:\:(?P<subcmd>\w+))?\s*'	// [$]foo[:bar]
				.'(?P<attrs>\w+=\".*?\")*\s*'				// attrn="attrv" ...
				.'(\}(?P<cont>.*?)\{\1)?\s*'				// [} ... {foo]
				.'\}~';										// }~
			return preg_replace_callback('/'.$pattern.'/mis', array($this,'parseSingleTag'), $template);
		}

		/**
		 * Echo wrapper for parse()
		 */
		public function render()
		{
			echo $this->parse();
		}

		/**
		 * Handles the replacement of single matched patterns
		 * @param  array $matches Array containing matched strings
		 * @return string          String to replace the pattern with
		 */
		private function parseSingleTag($matches)
		{
			$args['cmd'] = $matches['cmd'];
			$args['subcmd'] = (isset($matches['subcmd'])) ? $matches['subcmd'] : null;
			$args['attrs'] = (isset($matches['attrs'])) ? $this->parseTagAttributes($matches['attrs']) : array();
			$args['cont'] = (isset($matches['cont'])) ? trim($matches['cont']) : '';
			if(strpos($args['cmd'],	"$")!==false) {
				$args['cmd'] = substr($args['cmd'], 1);
				return $this->handleTag_label($args);
			} else {
				$callback = 'handleTag_'.$args['cmd'];
				if(!is_callable(array($this, $callback))) return $matches[0];
				return call_user_func(array($this, $callback), $args);
			}
		}

		/**
		 * Retrieves the attributes of the current matched string
		 * @param  string $attributes The string to parse in the form of attrname="value"
		 * @return array             Assoc array containing the extracted pairs
		 */
		private function parseTagAttributes($attributes)
		{
			$pattern = '(?P<attrname>\w+)=\"(?P<attrval>.*?)\"';
			$matches = array();
			preg_match_all('/'.$pattern.'/i', $attributes, $matches);
			$attrs = array();
			foreach ($matches['attrname'] as $idx=>$attrname) {
				$attrs[$attrname] = $matches['attrval'][$idx];
			}
			return $attrs;
		}

		/**
		 * Private tag handler. Replaces ~{$model:$property}~ with the correct value.
		 * @internal This could be encapsulated somewhere. Maybe a static class.
		 * @param  array  $opts Assoc array containing 'cmd' and 'subcmd' to retrieve from the view's model array
		 * @return string       The value of the $property inside $models[$cmd]
		 */
		private function handleTag_label($opts=array())
		{
			$opts = mergeParamsArray($opts, array(
				'cmd'		=> '',
				'subcmd'	=> ''
			));
			if($opts['cmd']===null||!$this->modelIsRegistered($opts['cmd'])) return "[CRVIEW] Parse error. Model '".$opts['cmd']."' not found on the registered models of this view.";
			if(!isset($this->getModel($opts['cmd'])->$opts['subcmd'])) return "[CRVIEW] Parse error. Property '".$opts['cmd']."' not found in '".$opts['cmd']."'.";
			
			return $this->getModel($opts['cmd'])->$opts['subcmd'];
		}

		/**
		 * Private tag handler. Replaces ~{view}~ with a fresh view loading the src attribute.
		 * @internal This could be encapsulated somewhere. Maybe a static class.
		 * @param  array  $opts Assoc array containing 'attrs' to get the 'src'
		 * @return string       The parsed template from src with $models context
		 */
		private function handleTag_view($opts=array())
		{
			$opts = mergeParamsArray($opts, array(
				'attrs'		=> array()
			));
			if(!isset($opts['attrs']['src'])) return "[CRVIEW] Parse error. Missing 'src' attribute.";
			$src = $opts['attrs']['src'];
			if(in_array($src, $this->stack)) return '<!-- [CRVIEW] Warning. Infinite View recursion. Aborting. -->'; // Break infinite loop.
			array_push($this->stack, $src);
			$newView = new View($this->models, $this->stack);
			if(!$newView->loadTemplate($src)) {
				array_pop($this->stack);
				return "[CRVIEW] Error. Couldn't load '".$src."'.";
			}
			$return = $newView->parse();
			array_pop($this->stack);
			return $return;
		}

		/**
		 * Private tag handler. Iterates ~{foreach}...{foreach}~ with the content of the 'collection' attribute using 'as' attribute to hold the current model. This creates internally a new View and uses it to parse the container.
		 * @internal This could be encapsulated somewhere. Maybe a static class.
		 * @param  array  $opts Assoc array containing 'attrs' to get the 'collection' and 'as'
		 * @return string       The parsed template from the content with $models context + current model available on the asigned key
		 */
		private function handleTag_foreach($opts=array())
		{
			$opts = mergeParamsArray($opts, array(
				'attrs'		=> array(),
				'cont'		=> ''
			));
			if(!isset($opts['attrs']['collection'])) return "[CRVIEW] Error. Collection to iterate not set.";
			$collection = $opts['attrs']['collection'];
			$cur = (isset($opts['attrs']['as'])) ? $opts['attrs']['as'] : 'item';
			if(!$this->modelIsRegistered($collection)) return "[CRVIEW] Parse error. Model '".$collection."' not found on the registered models of this view.";
			$final = "";
			if($this->modelIsRegistered($cur)) $final .= "<!-- [CRVIEW] Warning. Iterator name holder is currently used. This will override, then unregister the model named '".$cur."' -->\n";
			$nView = new View($this->models, $this->stack);
			foreach ($this->getModel($collection)->toArray() as $itm) {
				$nView->registerModel($cur, $itm);
				$final .= $nView->parse($opts['cont']);
				$nView->unregisterModel($cur);
			}
			return $final;
		}

		/**
		 * Private tag handler. Conditional element ~{if}...{if}~ This creates internally a new View and uses it to parse the container to support nested Ifs.
		 * @internal This could be encapsulated somewhere. Maybe a static class.
		 * @param  array  $opts Assoc array containing 'attrs' to get 'condition' and 'cont.
		 * @return string       The parsed template from the content with $models context
		 */
		private function handleTag_if($opts=array())
		{
			$opts = mergeParamsArray($opts, array(
				'attrs'		=> array(),
				'cont'		=> ''
			));
			if(!isset($opts['attrs']['condition'])) return "[CRVIEW] Error. Condition not set.";
			$cond = $opts['attrs']['condition'];
			// Replace $M:P variables with PHP literals
			$cond = preg_replace_callback('/\$(?P<cmd>\w+)\:(?P<subcmd>\w+)/mis', function($matches) {
				$c = $matches['cmd'];
				$s = $matches['subcmd'];
				if(!$this->modelIsRegistered($c)) return null;
				if(!isset($this->getModel($c)->$s)) return null;
				return $this->getModel($c)->$s;
			}, $cond);
			if(eval("return ".$cond." ;")) {
				$nView = new View($this->models, $this->stack);
				return $nView->parse($opts['cont']);
			}
			return "";
		}
	}

?>